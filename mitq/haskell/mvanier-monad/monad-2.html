<!DOCTYPE html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Yet Another Monad Tutorial (part 2: >>= and return)</title>
        <link rel="alternate" type="application/rss+xml" title="From Hask Til Dawn" href="../../../rss.xml" />
        <link rel="shortcut icon" href="../../../favicon.ico?v=2" type="image/x-icon" />
        <link rel="stylesheet" href="../../../css/bootstrap.min.css" />
        <link rel="stylesheet" href="../../../css/bootstrap-theme.min.css" />
        <link rel="stylesheet" href="../../../css/default.css" />
        <link rel="stylesheet" href="../../../css/syntax.css" />
          <link rel="stylesheet" href="../../../css/quotes.css" />
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet" />
        <script type="text/x-mathjax-config">
            MathJax.Hub.Config( { tex2jax: { inlineMath: [ ["\\(", "\\)"] ]
                                           , displayMath: [ ["\\[", "\\]" ] ]
                                           , processEscapes: true
                                           }
                              });



        </script>
        <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>

        <script type="text/javascript" src="../../../js/jquery.min.js">
        </script>
        <script type="text/javascript" src="../../../js/bootstrap.min.js">
        </script>

    </head>
    <body>
        <div class="container">


            <div id="header">

                <ul id="navigation" class="list-inline text-center">
                    <li class="logo"><a href="../../../">ԳԼԽԱՎՈՐ</a></i>
                    <li><a href="../../../hogi/">ՀՈԳԻ</a></li>
                    <li><a href="../../../mitq/">ՄԻՏՔ</a></li>
                    <li><a href="../../../marmin/">ՄԱՐՄԻՆ</a></li>
                    <li><a href="../../../rss.xml"><i class="fa fa-rss"></i></a></li>
                    <!-- <li><a href="/atom.xml"><i class="fa fa-rss"></i></a></li> -->
                </ul>
            </div>
            <div class="clear"></div>
            

  <div class="clear"></div>
            <div id="content">
                <div class="title text-center">
                    <h2>Yet Another Monad Tutorial (part 2: >>= and return)</h2>
                    <hr>
                </div>

                <div class="post-content">
<div id="toc"><h3>Table of contents</h3><ul>
<li><a href="#the-two-fundamental-monadic-operations">The two fundamental monadic operations</a></li>
</ul></div>
<p><a href="http://mvanier.livejournal.com/4305.html">original article</a></p>
<p>In the <a href="monad-1.html">previous article</a> I gave the conceptual background necessary to understand what monads are. Now I’m going to get into more of the details.</p>
<section id="the-two-fundamental-monadic-operations" class="level2">
<h2>The two fundamental monadic operations</h2>
<p>Remember when I said above that monads generalize function composition and function application? We’ll work through that here. Have patience: it’ll take a while.</p>
<p>By this point, I hope you have at least a vague sense of what monads “are” and what they are used for. However, as I said before, one of the keys to functional programming is the ability to compose functions to create new functions. Functional programmers talk about “composability” all the time, with the implication that if some aspect of a programming language isn’t composable, it’s probably not worth much. So if our newly-minted monadic functions were not composable, they wouldn’t be nearly as useful as they would be if they were. But as we’ll see, they aren’t composable using the standard Haskell function composition operator. Something more will be needed, and this will lead us to derive the two fundamental monadic operations (or at least their types).</p>
<p>Let’s say that we have two monadic functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> m b
<span class="ot">g ::</span> b <span class="ot">-&gt;</span> m c</code></pre></div>
<p>for some monad <code>m</code>. If you want a more specific example, you can imagine that <code>f</code> and <code>g</code> are in the <code>IO</code> monad, so we’d have</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="ot">g ::</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c</code></pre></div>
<p>but the same argument will apply for all monads. Remember that (for the <code>IO</code> case) the function <code>f</code> takes a value of type <code>a</code> and outputs a value of type <code>b</code>, possibly doing some (file or terminal) I/O along the way. Similarly, <code>g</code> takes a value of type <code>b</code> and outputs a value of type <code>c</code>, possibly doing some I/O along the way. Therefore, if we wanted to compose them, we’d hopefully end up with a function like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">h ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> c</code></pre></div>
<p><em>i.e.</em> a function that takes a value of type <code>a</code>, outputs a value of type <code>c</code>, and possibly does some I/O along the way (with the I/O somehow being the combination of the I/O activity for functions <code>f</code> and <code>g</code>). We can write this out as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">compose<span class="fu">:</span> 
  (<span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) 
with<span class="fu">:</span> 
  (<span class="ot">g ::</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c) 
to get<span class="fu">:</span> 
  (<span class="ot">h ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> c)</code></pre></div>
<p>However, our normal Haskell function composition operators won’t work for this purpose, because they don’t want the <code>IO</code> in the types. Let’s compare with similarly-typed pure functions <code>p</code>, <code>q</code>, and <code>r</code> that don’t do I/O:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">p ::</span> a <span class="ot">-&gt;</span> b
<span class="ot">q ::</span> b <span class="ot">-&gt;</span> c
<span class="ot">r ::</span> a <span class="ot">-&gt;</span> c </code></pre></div>
<p>Then we could compose them using either the <code>(.)</code> or the <code>(&gt;.&gt;)</code> operator as described above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(.) ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)
r <span class="fu">=</span> q <span class="fu">.</span> p
<span class="ot">(&gt;.&gt;) ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)
r <span class="fu">=</span> p <span class="fu">&gt;.&gt;</span> q</code></pre></div>
<p>Neither <code>(.)</code> or <code>(&gt;.&gt;)</code> will work with our monadic functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="ot">g ::</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c
<span class="ot">h ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> c
g <span class="fu">.</span> f     <span class="fu">--&gt;</span> <span class="kw">type</span> error<span class="fu">!</span> mismatch between <span class="dt">IO</span> b and b
f <span class="fu">&gt;.&gt;</span> g   <span class="fu">--&gt;</span> <span class="kw">type</span> error<span class="fu">!</span> mismatch between <span class="dt">IO</span> b and b</code></pre></div>
<p>The point is, you can’t use a monadic value of type <code>IO b</code> when a type of <code>b</code> is needed. (This is a very common bug when writing monadic Haskell programs.) What we want is a special monadic composition function which I’ll call <code>mcompose</code> (standing for “monadic compose”) which has the following type signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mcompose ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)</code></pre></div>
<p>This will work for any monad <code>m</code>, including the <code>IO</code> monad. Specialized to the <code>IO</code> monad, it will have the following type signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mcompose ::</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">IO</span> c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> c)</code></pre></div>
<p>Then we could use it like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">f ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="ot">g ::</span> b <span class="ot">-&gt;</span> <span class="dt">IO</span> c
<span class="ot">h ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> c
h <span class="fu">=</span> f <span class="ot">`mcompose`</span> g</code></pre></div>
<p>and <code>h</code> would have the correct type signature. (We’re using a spiffy syntactic feature of Haskell here, whereby any two-argument function can be turned into an infix operator by putting backquotes around it. Remember, operators in Haskell are just functions which happen to be placed between their operands.) Somehow, through (currently) mysterious means, the <code>mcompose</code> function (or operator, if you like) is able to</p>
<ol type="1">
<li>take the original input value of type <code>a</code></li>
<li>apply <code>f</code> to it (this is just normal function application) to get a result of type <code>IO b</code></li>
<li>take the value of type <code>IO b</code> output from <code>f</code> and extract the value of type <code>b</code> (this is what we couldn’t do before)</li>
<li>take the value of type <code>b</code> and apply <code>g</code> to it (again, this is just normal function application) to get the value of type <code>IO c</code>, which is the result.</li>
</ol>
<p>The only thing we can’t already do is step (3), extracting a value of type <code>b</code> from a value of type <code>IO b</code>. Now, we could do this if we had a function called <code>extract</code> with this type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extract ::</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> b</code></pre></div>
<p>or more generally for arbitrary monads,</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">extract ::</span> m b <span class="ot">-&gt;</span> b</code></pre></div>
<p>It turns out that such a function, if it existed, would destroy all the advantages of monads and pure functional programming! One of the reasons we wanted monads in the first place was to keep these special notions of computation (monadic functions) separate from normal (pure) functions, because otherwise there would be no way to guarantee that pure functions were in fact pure. This is an important point, so I’m going to spend a little bit of time on it, after which we’ll return to monadic composition.</p>
<blockquote>
<p><strong>Side note:</strong> In fact, some monads do have the equivalent of an <code>extract</code> function, and for most of those monads it doesn’t cause problems. All I’m saying is that a generic <code>extract</code> function that works for all monads is not allowed.</p>
</blockquote>
<p>What we would like is to ensure that functions that have non-monadic type signatures are pure functions. Now, in a sense, even our monadic functions are pure functions, because they are implemented in Haskell as pure functions that return monadic values. But what we want to guarantee is that non-monadic (pure) functions don’t even do that <em>i.e.</em> don’t even return monadic values. If that’s the case, they are certainly going to be pure functions. So a pure function <code>hh</code> of type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hh ::</span> a <span class="ot">-&gt;</span> c</code></pre></div>
<p>should never do (file or terminal) input/output, for instance, because if it did it would be required by the type system to have the type</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">hh ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> c</code></pre></div>
<p>instead. Guarantees like this, enforced by the type system, are one of the major strengths of Haskell. They allow us to glance at the type of a function and be 100% sure that that function doesn’t do input/output, for instance.</p>
<p>However, if we had the <code>extract</code> function, we could comp</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ff ::</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b
<span class="ot">gg ::</span> b <span class="ot">-&gt;</span> c
hh <span class="fu">=</span> ff <span class="fu">&gt;.&gt;</span> extract <span class="fu">&gt;.&gt;</span> gg  <span class="co">-- or equivalently: hh = gg . extract . ff</span></code></pre></div>
<p>So even though <code>hh</code> is never supposed to be doing I/O, if there was an <code>extract</code> function then you could build an <code>hh</code> function using normal function composition, it would have the type signature of a pure function, and yet it would do I/O. So much for separating I/O (and other monadic computations) from pure computations (recall that this was one of the main reasons for wanting monads in the first place). Note, by the way, that this is exactly the situation in most conventional programming languages, which is why the type systems of those languages can offer no guarantees that a function is pure. In Haskell we like pure functions and we use the type system to give us guarantees that pure functions are actually pure — and that means no <code>extract</code>function.</p>
<p>There’s one slight problem with what I just said: technically, it’s a lie. There is a function called unsafePerformIO that has the type IO a -&gt; a i.e. it’s an extract function for the IO monad only. The word “unsafe” is a clue that tells you that you should avoid using it unless you know exactly what you’re doing and are prepared for weird failures. I myself have never needed to use unsafePerformIO, but there are legitimate uses for it (for instance, deep down in the implementation of Haskell compilers). Just forget I even brought this up, OK? It’s embarrassing. Excuse me while I go wash my hands.</p>
<p>OK, I’m back. So far, we’ve established that (a) we want to be able to compose monadic functions, (b) we can’t do that with normal function composition in Haskell because we can’t convert monadic types into regular types, and (c) we can’t define an extract function to do that conversion, because that would screw up the purity of the rest of the language. So what do we do?</p>
<p>Well, first of all, note that we can get by with something simpler than an mcompose function. Let’s say we had an mapply (monadic apply) function that had this type signature:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mapply ::</span> m b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> m c</code></pre></div>
<p>or, more specifically for the IO monad:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mapply ::</span> <span class="dt">IO</span> b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> <span class="dt">IO</span> c) <span class="ot">-&gt;</span> <span class="dt">IO</span> c</code></pre></div>
<p>It’s called <code>mapply</code> because it’s very similar to the regular function application operators. For instance, recall the <code>&gt;$&gt;</code> operator we defined previously, which had this type signature (using <code>b</code> and <code>c</code> instead of <code>a</code> and <code>b</code> for type variables):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;$&gt;) ::</span> b <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> c</code></pre></div>
<p>This is the same as <code>mapply</code> except that the <code>m</code>s are gone (the types are not monadic types). With <code>mapply</code>, we could trivially define <code>mcompose</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mcompose ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)
mcompose f g x <span class="fu">=</span> (f x) <span class="ot">`mapply`</span> g  <span class="co">-- or: mapply (f x) g</span></code></pre></div>
<p>Note that since the <code>-&gt;</code> associates to the right in type signatures, the type signature of mcompose can be written without the final set of parentheses as:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mcompose ::</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> m c) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> m c
mcompose f g x <span class="fu">=</span> (f x) <span class="ot">`mapply`</span> g</code></pre></div>
<p>This may be easier to understand than the previous version, but they are equivalent. Note that <code>x</code> has type <code>a</code> and the result has type <code>m c</code>. So what we’re doing here is applying <code>f</code> to <code>x</code> to get a value of type <code>m b</code>, and using <code>mapply</code> on the <code>m b</code> value and the <code>g</code> function to get a value of type <code>m c</code>. So the upshot is, we don’t need <code>mcompose</code> to be defined for us if we have <code>mapply</code>, because we can use <code>mapply</code> to define <code>mcompose</code> ourselves. And, in fact, <code>mapply</code> is one of the two fundamental monadic operations. It’s normally called “bind” and is written as an infix operator with the symbol <code>&gt;&gt;=</code> as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b </code></pre></div>
<p>Note that I did a switch in the type signature, using <code>a</code> in place of <code>b</code> and <code>b</code> in place of <code>c</code>. It doesn’t matter since <code>a</code>, <code>b</code>, and <code>c</code> are type variables — they work for any types.</p>
<p>I’d just like to point out here that <code>&gt;&gt;=</code> has an incredibly abstract type. Its first argument is a value of type <code>m a</code>, where <code>a</code> can be any type at all and <code>m</code> is any monadic type constructor whatsoever. The second argument is a function of type <code>a -&gt; m b</code>, where <code>a</code> and <code>b</code> can be any types at all and <code>m</code> is again any monadic type constructor. The return value has type <code>m b</code>, where again <code>b</code> can be any type and <code>m</code> is any monadic type constructor. When you program in Haskell for long enough, this kind of type signature becomes second nature, but it can be intimidating to new Haskell programmers. If you specialize it to the <code>IO</code> monad, you get:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</code></pre></div>
<p>which, of course, is the type signature of an <code>IO</code>-specific monadic apply operator. We’ll see below that Haskell’s type class mechanism allows us to use the same operator name <code>&gt;&gt;=</code> for all the different specializations of this operator to different monads (how cool is that?).</p>
</section>
</div>

<div class="row">
        <span class="date  text-right">
            <i class="fa fa-calenda"></i> Posted on July 25, 2010
        </span>
        <span class="tags text-right" style="width: 100%">
            <ul class="list-inline"><li><i class="fa fa-tags"></i></li><li><a href="../../../tags/mvanier.html">mvanier</a></li><li><a href="../../../tags/monads.html">monads</a></li><li><a href="../../../tags/tutorials.html">tutorials</a></li><li><a href="../../../tags/haskell.html">haskell</a></li></ul>
        </span>
</div>

            </div>
            <div id="footer" class="col-md-12">
                <div class="row"><hr /></div>
                <div class="row">
                    <ul class="list-inline text-center">
                        <li>
                            <i class="fa fa-github"></i>
                            <a href="http://github.com/arthurvard" target="_blank">github</a>
                        </li>
                        <li>
                            <i class="fa fa-file-o"></i>
                            <a href="http://hub.darcs.net/arthur" target="_blank">darcshub</a>
                        </li>
                        <!-- <li>
                            <i class="fa fa-twitter-square"></i>
                            <a href="http://twitter.com/arthurvard"  target="_blank">twitter</a>
                        </li> -->
                        <li>
                            <i class="fa fa-user"></i>
                            <a href="http://www.haskellers.com/user/arthurvard" target="_blank">haskeller</a>
                        </li>
                        <li>
                            <i class="fa fa-envelope-o"></i>
                            <a href="mailto:alpmestan@gmail.com">artie.vard@gmail.com</a>
                        </li>
                        <li>© 1995-2016 <a href="../../../about.html">Arthur Vardanyan</a></li>
                    </ul>
                </div>
                <div class="row text-center">
                    Powered by  <a href="http://jaspervdj.be/hakyll" target="_blank">Hakyll</a>
                </div>
            </div>
        </div>

        <script type="text/javascript" src="../../../js/quotes.js">
        </script>
    </body>
</html>
