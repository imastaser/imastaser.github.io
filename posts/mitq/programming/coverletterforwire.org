---
title: Cover Letter for Wire
tags: haskell
date: 2018-06-06
description: draft
comments: true
toc: false
---

* Cover Letter

Hi,

I am excited about the opportunity to join a team that does functional
programming, uses open source tools and makes open source software.
I'm actively developing my side project that utilizes a few popular open source
tools  and the FP languages (Haskell, Elm) which interest me a lot.

I work in the team who use only Microsoft languages, tools and all on Windows OS.

In general, I learn FP concepts continuously using *Haskell*, *Racket*. On 2017
I decided to use Haskell to develop backend to serve IoT devices.
I'm going to build my cover letter by answering to the  [[https://wire.softgarden.io/job/2105535?l=en][requirements]] section
concerning what I have done and what I'm going to do in the future.
 All work was done single-handedly with zero experience in linux and all tools i
have used, I will do my best if i have chance to work with experts of FP, distributed and scalable systems.

* Requirements
** *Excited about designing, building, and running distributed and scalable systems
    I have manage to set up hetzner's virtual linux machines for development, testing and production, my
    [[http://imast.am/mitq/programming/deployment.html][set up notes]] (by looking to move use  ansible to automate set up process).
    I design the backend scalability in mind, each device know about two
    backends, first backend's address(will be moved on the AWS or IBC cloud) is burned
    into firmware this backend the devices uses to get configuration with second
    backend address which uses send data, for login, to auth to get commands and etc.
    Set up nginx.


 *TODO:*
      - investigate and use floating IPs that hetzner provide.
      - use docker technologies with private docker repository

** *Interest in statically-typed functional languages is a big plus
   I love to let the language to validate my program at compile time,
   I am very excited about GHC's ~GADTs, DataKinds, TypeFamilies,
   TypeOperators~ language extensions  that brings Dependent type elements to
   haskell.  Also I found also Elm language, which helps me to avoid writing code in
   JavaScript as much as possible. You can relax on code refactoring; the deep
   refactoring is not pain anymore.
   *TODO:*
    - try [[http://www.purescript.org/][purescript]]
** *Passion for clean code and elegant solutions (continuously improving current ones)
   I periodically re-wording and formatting my comments to help haddock generate
   better documents.
   I try to apply Haskell abstraction which make code shorter, also i like the
   dependently typed languages concepts and looking forward to use
   them. I think I have found and implemented some  elegant solutions in my current project: how
   to send commands to device, how to scale easily without any magic when there will be many devices.
   I use [[https://www.pivotaltracker.com/][pivotaltracker]] to track my stories and tasks, there is a "Epic"  section.
   Have written several tests for backend, need more.

*TODO:* mostly from "Epics" section
     - view for log files
     - encrypt all communication, use hardware encryptors on device side
     - move device configs to cloud
     - use web sockets for all, avoid ajax pooling from front end as much as possible.
     - audit database changes
     - move to use MQTT protocol in the device side.
     - set up swagger document page for endpoints.
     - write more tests
     - use real time monitoring of backend application metrics

** We highly value experience with:
- AWS (or other cloud providers)
  Use S3, Route53
  Testing to use IBM Cloud Iot platform to store device configs(first backend)

- Automating builds and deployments

  I have automated my deployment with [[http://nadarei.co/mina/][mina]], i use for both backend and for web
   application, it is DSL to describe deployment, which allows to generate
  on fly ngxin, logrotate  and other configuration based on deployment environments {Production, Test,
  Staging}, then mina translates to bash script and runs it on remote
  server. [[#samples][mina config smaple]]


  set up cron job for [[https://backup.github.io/backup/v4/installation/][backup gem]] to make and store db backups to S3

  I know about CI, have not set it up yet.


- Unix/Linux environments, including the ability to analyze and troubleshoot potential networking issues

 As I told already all my app live in linux, I enable firewall, open close ports, check
  which program listens for given port, ping, set domain name. These are usually
  what I have done related to the networking on Linux environments.

- Containerization technologies

  I set up docker and configure to run my web app on it, i know about ~
  Kubernetes and Docker Swarm~
  Next steps of migration to full dockerized deployment are:
  1. Build containers for:
     - postgreSQL
     - Redis
     - nginx
     - backend
     - web application

  2.  Configure Docker Orchestration

- Coding in Rust

  I heard about Rust that it has something similar which we have for Type classes in
  Haskell, also that it can be used to program for  Rasberry pi and is good for system
  programming, something that come to replace ~C~, this all what I know about
  Rust. I have never tried it, but language featuring looks promising.


*  samples

** Changelog
#+BEGIN_SRC markdown
Change Log / Release Notes

0.0.8
• add device_log table in migration, add log.db end point.
• fix lng & lat invalid format parsing exception, "Prelude.read: no parse"
• publish data to redis channel, to feed websocket on front-end.
• reset device activity key in redis when checking for auth.

0.0.7
• add patvers

0.0.6
• verbose error for auth token.
• remove debugMsg for development as well, from response.
• parse imei value from auth header, add flockLog function.
• add AuthTokenDBError type constructor
• add imei to command reponse as well.
• deal with patvers, get patver status update from device
• handle not registered device case

0.0.5
• log to slack all errors
• firmware download row by row
• create firmware tables and seeds for testing.
• add taxi specific field to trip
• DeviceData: remove temp, add angle
• add endpoints to get tariff by id, by number.
• add endpoints to get tariff group tariffs id array, get all tariffs.
• add command endpoints to get device command or commands list
• add taxi.order endpoints, start, stop collect order data and save to db
• use redis heavily
• set taxi_id, taxometer_id and shift_id to taxi_order when order created.

0.0.4
• add expire key to redis for device activity tracking
• parse trip status
• add redis to handle trip creation, collect trip points.
• rename device property, make shorter, add new fields.
• add script for deploying to remote via ssh, 80% done.

0.0.3
• parse latitude and longitude from NMEA coords format
• convert lat and lng to degrees
• make staging error more verbos, DebugMsg option
• add logging of request and response to file, formatted as json.
• add api/info, do not remove "Content-Type" Header for this /api/info path, TODO: dev more sophisticate mechanism to remove header

0.0.2
• make response json more simple, for easy parse in device side, reduce nesting level in json
• change /api/device.data accept json where numeric types represent as text. the numeric type in the device side loss precision, and for device it is easy send text. Develop the json parser that accept numbers or string without fail.
• alt, speed, angle can access string, int, rational, empty

0.0.1
• change Response format
• run sql scripts as migration
• Add some tests
• Improved Rest API, separate Lib module, improve exception catching

0.0.0
• Expose necessary endpoints for pro-prototyping.


#+END_SRC

** Deployment code sample (mina)
#+LABEL: sec:X

#+BEGIN_SRC ruby
desc "Populate logrotote"
task :'setup:logrotate_config' => :remote_environment do
  logrotate_conf = <<-LOGR.dedent
    #{fetch(:deploy_to)}/shared/Backup/log/*.log
    #{fetch(:deploy_to)}/shared/log/*.log
    #{fetch(:deploy_to)}/shared/log/*/*.log {
                daily
                dateext
                dateformat -%d.%m.%Y
                missingok
                rotate 5
                compress
                delaycompress
                notifempty
                sharedscripts
                copytruncate
                }
    LOGR

  command %{
      echo "-----> Populating log rotation config"
      echo "#{logrotate_conf}" > #{fetch(:deploy_to)}/shared/config/log_rotation.conf
      sudo chmod 644 #{fetch(:deploy_to)}/shared/config/log_rotation.conf
      # sudo ln -nfs #{fetch(:shared_path)}/config/log_rotation.conf /etc/logrotate.d/#{fetch(:application_name)}
      sudo cp #{fetch(:shared_path)}/config/log_rotation.conf /etc/logrotate.d/#{fetch(:application_name)}
      echo "-----> Done"
  }

 end

#+END_SRC



#+BEGIN_SRC ruby

task :test do
  set :deploy_to, "#{fetch(:deploy_to)}"
  set :rails_env, 'production'
  set :domain, 'test.taxicenter.am'
  set :www_domain, 'test.taxicenter.am'
end

task :staging do
  set :deploy_to, "#{fetch(:deploy_to)}-staging"
  set :rails_env, 'staging'
  set :domain, 'staging.taxicenter.am'
  set :www_domain, 'staging.taxicenter.am'
#  set :branch, 'develop'
end

task :production do
  set :rails_env, 'production'
  set :branch, 'master'
  set :domain, 'taxicenter.am'
  set :www_domain, 'www.taxicenter.am'
end


task :setup => :remote_environment do

  # Puma needs a place to store its pid file and socket file.
  command %(mkdir -p "#{fetch(:shared_path)}/tmp/")
  command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/tmp")

  command %(mkdir -p "#{fetch(:shared_path)}/log/")
  command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/log")
  command %(mkdir -p "#{fetch(:shared_path)}/log/puma")
    command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/log/puma")
  command %(mkdir -p "#{fetch(:shared_path)}/log/nginx")
  command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/log/nginx")

  command %(mkdir -p "#{fetch(:shared_path)}/tmp/sockets")
  command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/tmp/sockets")

  command %(mkdir -p "#{fetch(:shared_path)}/backup")
  command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/backup")

  command %(mkdir -p "#{fetch(:shared_path)}/tmp/pids")
  command %(chmod g+rx,u+rwx "#{fetch(:shared_path)}/tmp/pids")

  invoke :'setup:db:database_yml'
  invoke :'setup:db:redis_yml'
  invoke :'setup:puma_config'
  invoke :'setup:secrets_yml'
  invoke :'setup:nginx_config'
  invoke :'setup:logrotate_config'

end

desc "Deploys the current version to the server."
task :deploy => :remote_environment do
  # uncomment this line to make sure you pushed your local branch to the remote origin
  # invoke :'git:ensure_pushed'
  deploy do
    # Put things that will set up an empty directory into a fully set-up
    # instance of your project.
    comment "Deploying #{fetch(:application_name)} to #{fetch(:domain)}:#{fetch(:deploy_to)}"
    command %{pwd}
    invoke :'git:clone'
    invoke :'deploy:link_shared_paths'
    invoke :'bundle:install'

    # these 2 commands shoudl be run first time only
    if fetch(:first_run) == true
      invoke :'rails:db_create' #  creates the database
      invoke :'rails:db_schema_load' # creates tables and columns within the (existing) database following schema.rb
    end

    invoke :'rails:db_migrate'

    # first time only
    if fetch(:first_run) == true
      command %{#{fetch(:rails)} db:seed}
    end

    invoke :'rails:assets_precompile'

    #command %{sudo service reload}

    invoke :'deploy:cleanup'

    on :launch do
        command %{mkdir -p tmp/}
        command %{touch tmp/restart.txt}
        invoke :'puma:phased_restart'
    end
  end
end

#+END_SRC_
