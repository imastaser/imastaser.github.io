---
title: Ալգորիթմների անալիզ
tags: asymptotic, algorithms
date: 2021-01-18
description: DESCRIPTION
comments: true
toc: true
---

* Ալգորիթմ և Ծրագիր
*Ալգորիթմը* դա հաշվողական խնդրի լուծման քայլերի նկարագրությունն է:
*Ծրագրի* համար էլ կարող ենք նույնը ասել, ավելի լավ հասկանլու համար ինչ է ալգորիթմը՝ համեմատենք այն
ծարգրի հետ

#+BEGIN_SRC C

|    | Ալգորիթմ(Algorithm)                    | Ծրագիր(Program)                 |
|----+----------------------------------------+---------------------------------|
| 1. | Դիզայն՝ Թղթի վրա լուծում               | Իրականացում՝ ծրագրի մշակում,    |
|    | - Ինչպե՞ս պետք է աշխատի ծրագիրը        | կազմում                         |
|    | - Ի՞նչ պետք է անում                    |                                 |
|----+----------------------------------------+---------------------------------|
| 2. | Domain knowledge - ալգորիթմ կազմողը    | Ծրագրավորող՝ մարդ որը գրում է   |
|    | պետք է տիրապետի լուծվող խնդրի          | ծրագիրը                         |
|    | առարկայական որիտին                     |                                 |
|----+----------------------------------------+---------------------------------|
| 3. | Ցանկացած լեզու, մոտեցում հարմար է      | Միայն ծարագրավորման լեզու կարող |
|    | ալգորիթմ նկարագրելու համար             | է օգտագործվել ծրագրի համար      |
|----+----------------------------------------+---------------------------------|
| 4. | Ալգորիթմի նկարագրություն անկախ է       | կազված է երկաթից և Օպերացիոն    |
|    | երկաթից(Hardware), Ծրագրերից(Software) | համակրգերից                     |
|    | Օպերացիոն համակարգերից(OS)             |                                 |
|----+----------------------------------------+---------------------------------|
| 5. | Վերլուծություն(Analyze)՝ ալգորիթմի     | Տեսատավորում(Testing)՝ ծրագրի   |
|    | արդյունավետությունը ըստ ծախսած         | աշխատանքի ստուգում              |
|    | ժամանակի(time) և օգտագործած            |                                 |
|    | հիշողության(space)                     |                                 |
|----+----------------------------------------+---------------------------------|

#+END_SRC

*Նախնական վերլուծություն և Հետին թվով Տեստավորում*

Նախնական վերլուծության ընթարկում է ալգորիթը իսկ ծրագիրը՝ տեստավորվում է:
Նախնական վերլուծության արդյունքը ժամանակի(time) ֆունկցիան է 
և օգտագործված հիշողության(space) ֆունկցիան:


#+BEGIN_SRC C

|    | Նախնական վերլուծություն(Priori Analysis) | Հետին թվով Տեստավորում(Posteriori Testing) |
|----+------------------------------------------+--------------------------------------------|
| 1. | Ալգորիթմ                                 | Ծրագիրը                                    |
|----+------------------------------------------+--------------------------------------------|
| 2. | Անկախ լեզվից                             | Կախված լեզվից                              |
|----+------------------------------------------+--------------------------------------------|
| 3. | Անկախ երկաթից                            | Կախված երկաթից                             |
|----+------------------------------------------+--------------------------------------------|
| 4. | ժամանակի(time) և օգտագործած              | Watch time and bytes of memory             |
|    | հիշողության(space)                       |                                            |
|----+------------------------------------------+--------------------------------------------|

#+END_SRC

*Ալգորիթմի հատկությունները*
#+BEGIN_SRC C
- Մուտք(Input)՝  կարող է ենդունել 0 կամ ավել մուտքային տվյալներ
- Ելք(Output)՝ պետք է արտածի առնվազմ մեկ արդյունք
- Ընդհատություն(Finiteness)՝ պետք է ունենա վերջավոր թվով հրամաններ, պետք է կանգ առնի
- Արագություն
- Ըմբռնելիություն(Definiteness)՝ կամայական հրաման ունենա հստակ և միայն մեկ նշանակություն, բոլոր քայլերը հայտնի լինեն 
- Արդյոանավետություն(Effectiveness)՝ չանի ոչ անհրաժեշտ բաներ, ոչ պետքական բաներ 
- Համընդանրություն
#+END_SRC

*Ինչպես գրել ալգորիթմ*
Ալգորիլմ գերլու համար կարող է օգտագորղվել ցանկացած գրելաձև, դրա համար չկա ընդունված կոնկրետ ճիշտ գրելաձև 
Օրինակ՝

#+BEGIN_SRC C
  Algorithm Swap(a,b)
  Begin
    temp <- a; --- 1 unit of time
    a <- b;    --- 1 unit of time
    b <- temp; --- 1 uniot of time
  End.           ----
                 f(n) = 3
#+END_SRC

* Ալգորիթմների վերլուփության չախանիշները(criteria)
- *Ժամանակ(Time)* 
Երբ ալգորիթմ կամ ինչ որ պրոցէդուրա ենք մշակում պետք է այնպես անենք որ այն լինի 
ինչքան հնարավոր է արագ, այլ կերպ ասած էֆեկտիվ ժամանակի մեջ(time efficient): Ալգորիթմը գրելուց հետո 
պետք է վերլուծել հասկանալու համար ինչքան ժամանակ կծախսի տված `n` ծավալի մուտքային տվյալների համար, 
այն ժամանակային չախը որ կստանանք վերլուծության արդյունքում կլինի ֆոնւկցիայի տեսքով, մենք կստանանք 
ժամանակային ֆունկցիան:
- *Ծավալ(Space)* 
Քանի որ ալգորիթմ աղխատացնելու համար այն պետք է վերածենք ծրագրի, որը նոր կարողանականք
աշխատացնել մեքենայի վրա, հետևաբար կարևոր է հասկանալ գնահատել նաև թէ մեր ալգորիթմը ինչքան հիղողության ղավալը է
օգտագործում:

*Ժամանակ* և *Ծավալ* երկու կարևոր չափորոշիչներն ըստ որոնց վերլուծությունը ամենակարևորն է և առաջնահերթ արվում է, որից
հետո եթե կարիք կա ապա վերլուծում ենք ըստ այլ գործոնների, օրինակ՝
- Տվյալների փոխանցման ծավալՑանցի(Network COnsumption/Data transfer)
- Էներգիայի ծախսը սարքի վրա աշխատացնելիս (Power consumption on device)
- Պրոցեսորի ռեգիստրերի քանակը (how many CPU Registers uses)

* Ալգորիթմներ Գերլուծելու եղանակները

*Ի՞նչպես Վերլուծել Ալգորիթմը*

Փորձենք վերլուծել վերևում նկարագրված *Swap* ալգորիթմը՝
- Ի՞նչքան ժամանակ է ծախսում, բայց ի՞նչպես հաշվենք: Յուրաքանչյուր պարզ հրաման ալգորիթմում
տևում է միավոր ժամանակ, պարզ նշանակում է որ այն չունի ներդրված(nested) այլ հրամաններ, օրինակ մեկ այլ 
ալգորիթմի կանպչ և այլն: *Swap* ալգորիթմի ժամանակային ֆունկցիան f(n) = 3, հաստատուն(կոնստանտ) ֆունկցիա է:
- Ի՞նչքան հիշողության ծավալ է օգտագործում՝(Space analysis)
Պարզենք քանի հատ փոփոխական է օգտագործում 
#+BEGIN_SRC C
  temp - 1    
  a    - 1
  b    - 1
     --------
      3 words, S(n) = 3, սա նույնպես հաստատուն ֆունկցիա է
#+END_SRC

*Հաճախությունները հաշվելու եղանակ(Frequency count method)*

Եղանակը կայանում է նրանում որ՝
- յուրաքանթյուր հրամանին համապտասխանացնում ենք ժամանակի միավոր
- եթե հրամանը կրկնվում է ինչ որ քանակով, այլ կերպ ասած հրամանը ունի հաճախություն, ապա
  հրամանի կատարման հաճախությունը նույնպես հաշվում ենք

for ցիկլերում մեշ կհետաքրքրի միայն համեմատությունների ժամանակը, դրա համար for ցիկլին կատարմանը կվերագրենք 
(n+1) ժամանակային միավոր, իսկ ցեկլի մարմինը կկատարվի n անգամ:
Դիտարկենք օրինակներ՝

ա) Զանգվածի տարրերի գումարի ալգորիթմի վերլուծությունը
#+BEGIN_SRC C

|            |                        | Time                     | Space        |
|------------+------------------------+--------------------------+--------------+
|            | A = [4,5,3,2,1]        |                          | A - n words  |
|            | n = 5                  |                          | n - 1 word   |
|            | Algorithm  Sum(A,n)    |                          |              |
|            | {                      |                          |              |
|         1. | S = 0;                 | 1 - unit of time         | S - 1 word   |
|         2. | for(i = 0; i < n; i++) | n + 1 - only comparision | i - 1 word   |
|            | {                      | i values  {0,1,2,3,4,5}  |              |
|         3. | S = S + A[i];          | n - unit of time         |              |
|            | }                      |                          |              |
|         4. | return S;              | 1 - unit of time         |              |
|            | }                      |                          |              |
|            |                        |                          |              |
|------------+------------------------+--------------------------+--------------+
|  functions |                        | f(n) = 2n+3              | S(n) = n + 3 |
| complexity |                        | Time: O(n)               | Space: O(n)  |
              
#+END_SRC


բ) Երկու nxn մատրիցաների գումարի ալգորիթմի վերլուծենք հաճախությունների հաշվման եղանակով
#+BEGIN_SRC C

|            |                           | Time                      | Space           |
|------------+---------------------------+---------------------------+-----------------+
|            | A = [nxn] matrix          |                           | A - n^2 words   |
|            | B = [nxn] matrix          |                           | B - n^2 words   |
|            | C = [nxn] matrix          |                           | C - n^2 words   |
|            | n                         |                           | n - 1 word      |
|            | Algorithm  Add(A,B,n)     |                           |                 |
|            | {                         |                           |                 |
|            | for(i = 0; i < n; i++)    | n + 1 - nly comparisions  | i - 1 word      |
|            | {                         |                           |                 |
|            | for(j = 0; j < n; j++)    | n * (n + 1) - body * comp | j - 1 word      |
|            | {                         |                           |                 |
|            | C[i,j] = A[i,j] + B[i,j]; | n * n - unit of time      |                 |
|            | }                         |                           |                 |
|            | }                         |                           |                 |
|            | }                         |                           |                 |
|------------+---------------------------+---------------------------+-----------------+
| functions  |                           | f(n) = 2n^2 + 2n + 1      | S(n) = 3n^2 + 3 |
| complexity |                           | Time: O(n^2)              | Space: O(n^2)   |
#+END_SRC
              

բ) Երկու nxn մատրիցաների արտադրյալի ալգորիթմի վերլուծությունը
#+BEGIN_SRC C
#+END_SRC

|            |                                    | Time                             | Space           |
|------------+------------------------------------+----------------------------------+-----------------+
|            | A = [nxn] matrix                   |                                  | A - n^2 words   |
|            | B = [nxn] matrix                   |                                  | B - n^2 words   |
|            | C = [nxn] matrix                   |                                  | C - n^2 words   |
|            | n                                  |                                  | n - 1 word      |
|            | Algorithm  Multiply(A,B,n)         |                                  |                 |
|            | {                                  |                                  |                 |
|            | for(i = 0; i < n; i++)             | n + 1 - only comparisions of i<n | i - 1 word      |
|            | {                                  |                                  |                 |
|            | for(j = 0; j < n; j++)             | n * (n + 1) - body * comp        | j - 1 word      |
|            | {                                  |                                  |                 |
|            | C[i,j] = 0;                        | n * n  - unit of time            |                 |
|            | for(k = 0; k < n; k++)             | n * n * (n + 1) - body * comp    | k - 1 word      |
|            | {                                  |                                  |                 |
|            | C[i,j] = C[i,j] + A[i,k] * B[i,j]; | n * n * n - unit of time         |                 |
|            | }                                  |                                  |                 |
|            | }                                  |                                  |                 |
|            | }                                  |                                  |                 |
|            | } // end algorithm                 |                                  |                 |
|------------+------------------------------------+----------------------------------+-----------------+
| functions  |                                    | f(n) = 2n^3 + 3n^2 + 2n + 1      | S(n) = 3n^2 + 4 |
| complexity |                                    | Time: O(n^3)                    | Space: O(n^2)   |

* Ժամանակային բարդություն
Մանրամասն օրինակներ ժամանակային վերլուծության տարբեր դեպքերի համար

1. Միայնակ ցիկլ

Ցիկլերի համար կարոծ ենք անտեսել (n + 1) համեմատությունները որոնք ծախսվում են հենց ցիկլ կազմակերպելու համար, 
այն պարզ պատճառով որ այն չի փոխում ժռամանակային ֆունկցիայի աստիճանը:

#+BEGIN_SRC C
   for(i = 0; i < n; i++) -- n + 1, այսուհետ հաշվի չենք առնի այս գործակիցը  
   {
     statement;          -- n  => O(n)
   }


  for(i = n; i > 0; i--) - decrementing order n -> 1
   {
     statement;          -- n  => O(n)
   }


  for(i = 1; i < n; i = i + 2) ավելի ընդհանուր դեպքը`` i = i + k
   {                i = i + k   
     statement;          -- n/2 => f(n) = n/2 => O(n)
                         -- n/k => f(n) = n/k => O(n)  
   }


#+END_SRC



2. Կրկնակի ցիկլեր
#+BEGIN_SRC C
  for(i = 0; i < n; i++)   -- n + 1
  {
    for(j = 0; j < n; j++) -- n * (n+1)
      {
        statement;         -- n * n
      }                   f(n) = 2n^2 + 2n+2 => O(n^2)
  }


  for(i = 0; i < n; i++)                          
  { 
    for(j = 0; j < i; j++) 
      {
        statement;         -- n * (n + 1)/2 see below table  
      }                   f(n) = (n^2 + n)/2 => O(n^2)
  }

                                                                                        
|   i |   j | count |
|-----+-----+-------|
|   0 |  0x |     0 |
|   1 |   0 |     1 |
|     |  1x |       |
|   2 |   0 |     2 |
|     |   1 |       |
|     |  2x |       |
|   3 |   0 |     3 |
|     |   1 |       |
|     |   2 |       |
|     |  3x |       |
| ... | ... |   ... |
|   n |   0 |     n |
|     |   1 |       |
|     | ... |       |
|     |  nx |       |
  
#+END_SRC

3. Ցիկլի պայմանի փոփոխություն մարմնում
#+BEGIN_SRC C
  for(i = 1; p <= n; i++)       i  p 
  {                             1  0 + 1 = 1
    p = p + i;                  2  1 + 2 = 3
  }                             3  1 + 2 + 3 = 6
                                ....
                                k  1+2+3+...+k = k*(k+1)/2  

ցիկլը կանգ է առնում երբ p>n, Ենթադրենք k քայլում => p = k*(k+1)/2  
k*(k+1)/2 > n ~ k^2 > n => k > √n
#+END_SRC
4.
#+BEGIN_SRC latex

  for(i = 1; i <= n; i=i*2)     i   
  {                             1x2 = 2  
    statment; -- logn           2x2 = 4 = 2^2   
  }                             4x2 = 8 = 2^3 
                                ....
                                2^k  
ցիկլը կանգ է կաառնի երբ i>=n, Ենթադրենք k քայլում i >= n
i = 2^k
2^k >= n, եթե վերցնենք 2^k = n => k = log 2 n
O(log2n)
Օրինակ n=8
i
1
2
4
8 - ցիկլի վերջ
log8 = 3

Օրինակ n=10
i
1
2
4
8
16 - ցիկլի վերջ
log10 = 3,2, բայց մենք կլորացնում ենք դեպի վերև, քանի որ ցիկլը կրկնվում է 4 անգամ: երբ կոտորակային թիվ ենք ստանում 
պետք է որոշենք թէ որ կոծմ ենք կլորացնում՝ վերև թէ ներքև:
#+END_SRC

5.
#+BEGIN_SRC C
  for(i = n; i >= n; i=i/2)          
  {                             i ->  n, n/2, n/2^2, n/2^3, ..., n/2^k 
    statement;                    
  }                               
                                
                                  

ցիկլը կանգ  կառնի երբ i < 1, Ենթադրենք k քայլում => i<1 => n/2^k < 1
վերցնենք  n/2^k = 1, k = log2 n

O(log2  n)

#+END_SRC

6.
#+BEGIN_SRC C

  for(i = 0; i*i < n; i++)       1   
  {                             i n n/2 n/2^2 n/2^3 ... n/2^k 
    statement;                    
  }                               
                                
                                  

ցիկլը կանգ  կառնի երբ i*i >=n, վերցնենք  i^2 = n => i = √n

O(√n)

#+END_SRC



7. Երկու անկխա ցիկլեր
#+BEGIN_SRC C
  for(i=0; i < n; i++)
  {
    P++;  -- n 
  }
  for(j=0; j < n; j++)
  {
    statement;  -- n
  }
f(n) = 2n
O(n)
#+END_SRC

8. Կրկնակի ցիկլ
#+BEGIN_SRC C
  for(i=0; i < n; i=i*2)
  {
    P++;  -- P = log2 n 
  }
  for(j=0; j < P; j=j*2)
  {
    statement;  -- log2 P => log2 log2 n => O(log log2 n)
  }

#+END_SRC


2. Կրկնակի ցիկլ
#+BEGIN_SRC C
#+END_SRC
2. Կրկնակի ցիկլ
#+BEGIN_SRC C
#+END_SRC
2. Կրկնակի ցիկլ
#+BEGIN_SRC C
#+END_SRC
2. Կրկնակի ցիկլ
#+BEGIN_SRC C
#+END_SRC
