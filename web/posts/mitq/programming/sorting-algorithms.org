---
title: Տեսակավորման ալգորիթմներ
tags: sorting, algorithms
date: 2020-12-02
description: DESCRIPTION
comments: true
toc: true
---

* Տեսակավորման ալգորիթմներ
*Կայունությունը (stability)* - եթե տեսակավորման ալգորիթմը պահպանում է հավասար էլեմնենտների խոխադարձ տեղակայումը, 
ապա այսպիտի սորտավորման ալգորիթմը կանվանենք կայուն:

*Ադապտիվություն (adaptive)* - կասենք տեսակավորման ալգորիթմը ադապտիվ է եթե նախօրոք 
սորտավորված տվյալների վրա ավելի արդյունավետ է աշխատում՝ ցուցադրում է իր լավագույն տարբերակը:

*Տվյալների կառուցվածքը* եթե հատուկ չի նշվում, ալգորթմը նկարագրելիս, նշանակում է խոսքը միաչափ զանգվածի մասին է

#+BEGIN_SRC C

|------------------------------+--------+----------+------+--------+---------+-------------------------+--------------|
| Տեսակավորման ալգորիթմներ     | Stable | Adaptive | Best | Worst  | Average | Type                    | Extra Memory |
|------------------------------+--------+----------+------+--------+---------+-------------------------+--------------|
| Պղպջակային (Bubble sort)     | Yes    | Yes      | O(n) | O(n^2) | O(n^2)  | Comparision based sorts | O(1)         |
| Տեղադրմամբ (Insertion sort)  | Yes    | Yes      | O(n) | O(n^2) | O(n^2)  |                         | O(1)         |
| Ընտրւոթյամբ (Selection sort) |        |          |      |        |         |                         | O(1)         |
|                              |        |          |      |        |         |                         |              |
|                              |        |          |      |        |         |                         |              |
| Count Sort                   |        |          |      |        |         | Index base sorts        |              |
| Bucket/Bin Sort              |        |          |      |        |         |                         |              |
| Redix Sort                   |        |          |      |        |         |                         |              |
|------------------------------+--------+----------+------+--------+---------+-------------------------+--------------|

#+END_SRC

** Պղպջակային (Bubble sort ) 
Համեմատության եղանակով տեսակավորման ալգորիթմ է, որը կարգավորում է զանգվածը ցույգ առ ցւոյգ 
համեմատելով հարևան էլեմնենտերը և տեղափոխելով իրար միջև եթե սխալ են դասավորված իրար նկատմամբ: 
Այսպիսի մի համեմատությունների և տեղափոխությունների անցումի մեկ ցիկլը էլեմենտների վրայով 
կանվանենք *Փաս(Pass)*: Առաջին Փասի արդյունքում մեկ էլեմենտ կգտնի իր տեղը, մեծագույն էլեմենտը զանգվածում կկարգավորվի: 
`n` էլեմնետ ունեցող զանգվածում հարկավոր կլինի n-1 Փաս ամբողձ զանգված հերթականուլյամբ դասավորելու համար: 
Իսկ n էլեմենտի համար պետք է կատարել n-1 համեմատություն և մաքսիմում n-1 տեղափոխություն՝
հերթական «ծանր» էլեմենտը իր տեղ դնելու համար: 
#+BEGIN_SRC C
  int A[] = {9,6,8,4,3}

| I Pass         | II Pass      | III Pass     | IV Pass      |
|----------------+--------------+--------------+--------------|
| 9] 6  6  6  6  | 6] 6  6  6   | 6] 4  4      | 4] 3.        |
| 6] 9] 8  8  8  | 8] 8] 4  4   | 4] 6] 3      | 3] 4.        |
| 8  8] 9] 4  4  | 4  4] 8] 3   | 3  3] 6.     | 6. 6.        |
| 4  4  4] 9] 3  | 3  3  3] 8.  | 8. 8. 8.     | 8. 8.        |
| 3  3  3  3] 9. | 9. 9. 9. 9.  | 9. 9. 9.     | 9. 9.        |
|----------------+--------------+--------------+--------------|
| sorted el.  9  | sorted el. 8 | sorted el. 6 | sorted el. 4 |
| #Comp: 4       | #Comp: 3     | #Comp: 2     | #Comp: 1     |
| #Swap: 4       | #Swap: 2     | #Swap: 2     | #Swap: 1     |
| #max swap: 4   | #max swap: 3 | #max swap: 2 | #max swap: 1 | 
#+END_SRC
  

*** Վերլուծություն
#+BEGIN_SRC C
Դիցուք ունենք n տարրանի զանգված, ապա.
- Փասերի քանակը՝ (n-1)
- Համեմատությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
- Մաքսիմալ հնարավոր տեղափոխությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)

#+END_SRC
*** Կայուն է - այո
#+BEGIN_SRC C
|--------------------|
| 9 ] 9   9   9   9  | No change of order, => Bubbke sort is stable
| 9*] 9*] 3   3   3  |
| 3   3 ] 9*] 5   5  |
| 5   5   5 ] 9*] 4  |
| 4   4   4   4 ] 9* |
|--------------------|
#+END_SRC

*** Ադապտիվ է - այո
Պղպջակային ալգորիթմը իր բնույթով *ադապտիվ* չէ, բայց այն հնարավոր է դարձնել ադապտիվ, 
կոդի մեջ այդ նպատակի համար օգտագործում ենք flag փոփոխականը որողելու համար հերթական փասի 
ընթացքում գոնե մեկ տեղափոխություն(swap) եղել է, եթե չի եղել նշանակում է տվյալնեն արդեն
կարգավրոված են:

#+BEGIN_SRC C
| sorted list   |
|---------------|
| 3] 3  3  3  3 | No swaping, mean list already sorted, we use 
| 4] 4] 4  4  4 | flag to determine if ther is swap and made 
| 6  6] 6] 6  6 | buuble sort algorithm adaptive, it is not 
| 8  8  8] 8] 8 | adaptive by iteself, but it is possible to 
| 9  9  9  9] 9 | make it adaptive.
|---------------|
| #Comp: 4      |
| #Swap: 0      | => O(n) - if already sorted, minimum time 
| #max swap: 4  |
#+END_SRC

*** Դիտողություններ
-  Այս տեսակավորման միջանկյալ արդյունքները՝ k Փաս-ից հետո,  k < n-1, նույնպես կարող են օգտակար լինեն, 
   քանի որ ամեն Փասի ընթացքում «ամենածանր» տարրը իջնում է ներքև, հետևաբար 1-ին փասից հետո կունենաք
   մեծագույն տարրը, 2-րդից հետո երկու մեծագույն տարրերը և այդպես շարունակ:
   


*** Կոդ
#+BEGIN_SRC C
void BubbleSort(int A[], int n)
{
 // no swapping means the list already sorted
 // we use flag to determine if there is a swap. 
 int flag = 0;
 for(i = 0; i < n-1; i++) // passes
 {
   for(j = 0, flag = 0; i < n-1-i; j++) // every pass reduced comparision count 
   {
     if(A[j] > A[j+1])
     {
       swap(A[j], A[j+1]);
       flag = 1;  
     }
   }
   if(flag == 0) break;  
 }
}
#+END_SRC




** Տեղադրմանբ (Insertion sort) 
- Նախ հասկանանք ի՞նչ նկատո ունենք *տեղադրում* ասելով
#+BEGIN_SRC C
int A[] = {2,6,10, * ,15,20,25,30}
int new_element = 12
#+END_SRC
Դիգուք ունենք հերաթականությմաբ դասավորված զանգվածը որի մեջ ուոզում ենք դեծադրել նոր էլեմենտ 12 
իր իր տեղում որ չխաղտի դասավորվածությունը: Դրա համար պետք է անել երկու բան
1. գտնել 12 տեղը զանգվածում
2. և տեղափոխել այդ տեղից սկսած բոլոր տարրերը դեպի աջ, ազատելով 12 տեղը

Ավելի օպտիմալ կլինի եթե շրջանցենք առաջին քայլը՝ սկսենլով ուղղակի տեծափոխել զանգվածի վերջին 
էլեմենտը դեպի աջ և միաժամանակ փնտրելով նոր տեծադրվոծ էլեմենտի տեղը.

#+BEGIN_SRC C
int A[] = {2,6,10,15,20,25,30,*}
int new_element = 12

- 30 > 12 Yes, shift it - {2,6,10,15,20,25,*,30}
- 25 > 12 Yes, shift it - {2,6,10,15,20,*,25,30}
- 20 > 12 Yes, shift it - {2,6,10,15,*,20,25,30}
- 15 > 12 Yes, shift it - {2,6,10,*,15,20,25,30}
- 10 > 12 No,  insert   - {2,6,10,12,15,20,25,30}

// in case Linked list
Node<int> first = 2 --> 6 --> 10 --> 15 --> 20 --> 25 --> 30
p = first;
q = NULL; //tail pointer
x = 18;
// we do not need shifting in linked list, we just need to trabel and fine out the right position of new element

procedure:
- p.data < x, yes q = p; p = p.next;
- p.data < x, yes q = p; p = p.next;
.......
- p.data < x, no, t = new Node(x);, t.next = p; q.next = t;

Min number of Comparisions: 0   ~ O(1)
Max number of Comparisions: n-1 ~ O(n)

Number of Swaps:        0 , not required    

#+END_SRC



*Ալգորիթմը*

Դիցուք ունենք 5 տարրանի A զանգվածը, պետք է տեսակավորենք: 
Ենթադրում ենք որ առաջին տարր իր տեղում է, իսկ մնացած 4 տարրերը պետք է դասավորենք *տեղադրով* մեկ առ մեկ՝
վերը նկարագրված եղանակով. առաջին մի տարրանի սորտավորված զանգվածի մեջ.

#+BEGIN_SRC C
int A[] = {9,6,8,4,3}

| I Pass            | II Pass           | III Pass           | IV Pass           |
|-------------------+-------------------+--------------------+-------------------|
| 9 * 8 4 3         | 6 9 * 4 3         | 6 8 9 * 3          | 4 6 8 9 *         |
| 6                 | . 8               | . . 4              | . . . 3           |
| 9 > 6, yes, shift | 9 > 8, yes, shift | 9 > 4, yes, shift  | 9 > 4, yes, shift |
| 6 9 8 4 3         | 6 * 9 4 3         | 6 8 * 9 3          | 4 5 8 * 9         |
|                   | 8                 | . 4                | . . 3             |
|                   | 6 > 8, no, insert | 8 > 4, yes, shift  | 8 > 3, yes, shift |
|                   | 6 8 9 4 3         | 6 * 8 9 3          | 4 5 * 8 9         |
|                   |                   | 6 > 4, yes, shift  | . 3               |
|                   |                   | * 6 8 9 3          | 5 > 3, yes, shift |
|                   |                   | 4                  | 4 * 5 8 9         |
|                   |                   | no element, insert | 3                 |
|                   |                   | 4 6 8 9 3          | 4 > 3, yes, shift |
|                   |                   |                    | * 4 5 8 9         |
|                   |                   |                    | 3, insert         |
|                   |                   |                    | 3 4 5 8 9         |
|-------------------+-------------------+--------------------+-------------------|
| sorted el.  6     | sorted el. 8      | sorted el. 4       | sorted el. 3      |
| #Comp: 1          | #Comp: 2          | #Comp: 3           | #Comp: 4          |
| #Swap: 1          | #Swap: 1          | #Swap: 3           | #Swap: 4          |
| #max swap: 1      | #max swap: 2      | #max swap: 3       | #max swap: 4      |

#+END_SRC

*** Վերլուծություն
#+BEGIN_SRC C
Դիցուք ունենք n տարրանի զանգված, ապա.
- Փասերի քանակը՝ (n-1)
- Համեմատությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
- Մաքսիմալ հնարավոր տեղափոխությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)

|      | min - Best case    | max: Worst case     |
|------+--------------------+---------------------|
| Time | O(n)               | O(n^2)              |
| Swap | O(1)               | O(n^2)              |
|------+--------------------+---------------------|
|      | in ascending order | in descending order |

#+END_SRC

*** Կայուն է - այո
Դիտարկենք զանգված որը տեսակավորել ենք տեադրմամբ, և ունենք կնկնվող էլեմենտ 6' որի հերթն է տեծադրելու 
զանգվածի կարգավորված մասում, քանի որ մենք ստուգում ենք աջից խիստ անհավասարություն, այսինք հավասար էլեմենտնրը չի 
տեղափոխում, արդյունքում էլ այս երկրորդ 6' կհայտնվի առաջին վեցից աջ, ինչպես չկարգավորված զանցվածում էր, 
հետԵբար տեղադրմամբ տեսակավորումը կայուն է:

#+BEGIN_SRC C
    |----------------|
    | 4 6 9 11 12 *  |
    |          6'    |
    |    . . .       |
    | 4 6 6' 5 11 12 |
    |----------------|
#+END_SRC


*** Ադապտիվ է - այո
Տեղադրությամբ տեսակավորումը ադապտիվ է իր բնույթով՝ կարիք չկա լրացուցիչ ինչ որ
flag կամ այլ մի բան օգտագործենլու որպեսզի այն դառնա ադապտիվ:

#+BEGIN_SRC C
int A[] = {3,6,9,10,12}

| I Pass            | II Pass           | III Pass           | IV Pass             |
|-------------------+-------------------+--------------------+---------------------|
| 3 * 9 10 12       | 3 6 * 10 12       | 3 6 9 * 12         | 3 6 9 10 *          |
| 6                 | . 9               | . . 10             | . . . 12            |
| 3 > 6, no, insert | 6 > 9, no, insert | 9 > 10, no, insert | 10 > 12, no, insert |
|-------------------+-------------------+--------------------+---------------------|
| #Comp: 1          | #Comp: 1          | #Comp: 1           | #Compo: 1           |
| #Swap: 0          | #Swap: 0          | #Swap: 0           | #Swap: 0            | 

Number of Comparisions: n - 1 ~  O(n)
Number of Swaps:        0 ~ O(1) 

#+END_SRC

*** Դիտողություններ
- Տեղադրմամբ տեսակավորումը չունի օգտակար միջանկյալ արդյունք՝ k Փաս-ից հետո,  k < n-1
- Այս տեսակավորումը իրականացնելիս նպատակահարմար է օգտագործել կապակցված ցուցակ, որովհետև 
  էլեմենտների տեծափոխությյուն կատարելու անհրաժեշտությունը չկա: Հակառակն էլ է ճիշտ, կապակզված 
  ցուցակ տեսակավրոելու համար ավելի հարմար է տեղադրմամբ տեսակավորման ալգորիթմը:

*** Կոդը
#+BEGIN_SRC C
  void InsertionSort(int A[], int n)
  {
    int i, j, x;
    for(i = 1; i < n; i++) //passes
    {
      j = i - 1;
      x = A[j]; // the element we want to sort, to insert in the sorted part of array
      while(j > -1 && A[j] > x)
      {
        A[j + 1] = A[j];
        j--;  
      }
      A[j + 1] = x;
    }
  }
#+END_SRC


** Ընտրությամբ (Selection sort)
** Արագ (Quick sort)
