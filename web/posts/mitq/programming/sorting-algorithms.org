---
title: Sorting Algorithms
tags: sorting, algorithms
date: 2020-12-02
description: DESCRIPTION
comments: true
toc: true
---

* Տեսակավորման ալգորիթմներ
*Կայունությունը (stability)* - եթե տեսակավորման ալգորիթմը պահպանում է հավասար էլեմնենտների խոխադարձ տեղակայումը, 
ապա այսպիտի սորտավորման ալգորիթմը կանվանենք կայուն:

*Ադապտիվություն (adaptive)* - կասենք տեսակավորման ալգորիթմը ադապտիվ է եթե նախօրոք 
սորտավորված տվյալների վրա ավելի արդյունավետ է աշխատում՝ ցուցադրում է իր լավագույն տարբերակը:

*Տվյալների կառւոցվաջքը* եթե հատուկ չի նշվում, ալգորթմը նկարագրելիս, նշանակում է խոսքը միաչափ զանգվածի մասին է

#+BEGIN_SRC C
| Տեսակավորման ալգորիթմներ | Stable | Adaptive | Best | wORST  | aVERAGE | tYPE                    | eXTRA MEMORY |
|--------------------------+--------+----------+------+--------+---------+-------------------------+--------------|
| Պղպջակային տեսակավորում  | Yes    | Yes      | O(n) | O(n^2) | O(n^2)  | Comparision based sorts | No           |
|                          |        |          |      |        |         | Index base sorts        |              |
|--------------------------+--------+----------+------+--------+---------+-------------------------+--------------|
#+END_SRC
** Պղպջակային (Bubble sort ) 
Համեմատության եղանակով տեսակավորման ալգորիթմ է, որը կարգավորում է զանգվածը ցույգ առ ցւոյգ 
համեմատելով հարևան էլեմնենտերը և տեղափոխելով իրար միջև եթե սխալ են դասավորված իրար նկատմամբ: 
Այսպիսի մի համեմատությունների և տեղափոխությունների անցումի մեկ ցիկլը էլեմենտների վրայով 
կանվանենք *Փաս(Pass)*: Առաջին Փասի արդյունքում մեկ էլեմենտ կգտնի իր տեղը, մեծագույն էլեմենտը զանգվածում կկարգավորվի: 
`n` էլեմնետ ունեցող զանգվածում հարկավոր կլինի n-1 Փաս ամբողձ զանգված հերթականուլյամբ դասավորելու համար: 
Իսկ n էլեմենտի համար պետք է կատարել n-1 համեմատություն և մաքսիմում n-1 տեղափոխություն՝
հերթական «ծանր» էլեմենտը իր տեղ դնելու համար: 
#+BEGIN_SRC C
  int A[] = {9,6,8,4,3}

| I Pass         | II Pass      | III Pass     | IV Pass      |
|----------------+--------------+--------------+--------------|
| 9] 6  6  6  6  | 6] 6  6  6   | 6] 4  4      | 4] 3.        |
| 6] 9] 8  8  8  | 8] 8] 4  4   | 4] 6] 3      | 3] 4.        |
| 8  8] 9] 4  4  | 4  4] 8] 3   | 3  3] 6.     | 6. 6.        |
| 4  4  4] 9] 3  | 3  3  3] 8.  | 8. 8. 8.     | 8. 8.        |
| 3  3  3  3] 9. | 9. 9. 9. 9.  | 9. 9. 9.     | 9. 9.        |
|----------------+--------------+--------------+--------------|
| sorted el.  9  | sorted el. 8 | sorted el. 6 | sorted el. 4 |
| #Comp: 4       | #Comp: 3     | #Comp: 2     | #Comp: 1     |
| #Swap: 4       | #Swap: 2     | #Swap: 2     | #Swap: 1     |
| #max swap: 4   | #max swap: 3 | #max swap: 2 | #max swap: 1 | 
#+END_SRC
  

*** Վերլուփություն
#+BEGIN_SRC C
Դիցուք ունենք n տարրանի զանգված, ապա.
- Փասերի քանակը՝ (n-1)
- Համեմատությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
- Մաքսիմալ հնարավոր տեղափոխությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
#+END_SRC
*** Կայուն է - այո
#+BEGIN_SRC C
|--------------------|
| 9 ] 9   9   9   9  | No change of order, => Bubbke sort is stable
| 9*] 9*] 3   3   3  |
| 3   3 ] 9*] 5   5  |
| 5   5   5 ] 9*] 4  |
| 4   4   4   4 ] 9* |
|--------------------|
#+END_SRC

*** Ադապտիվ է - այո
Պղպջակային ալգորիթմը իր բնույթով *ադապտիվ* չէ, բայց այն հնարավոր է դարձնել ադապտիվ, 
կոդի մեջ այդ նպատակի համար օգտագործում ենք flag փոփոխականը որողելու համար հերթական փասի 
ընթացքում գոնե մեկ տեղափոխություն(swap) եղել է, եթե չի եղել նշանակում է տվյալնեն արդեն
կարգավրոված են:

#+BEGIN_SRC C
| sorted list   |
|---------------|
| 3] 3  3  3  3 | No spwaing, mean list already sorted, we use 
| 4] 4] 4  4  4 | flag to determine if ther is swap and made 
| 6  6] 6] 6  6 | buuble sort algorithm adaptive, it is not 
| 8  8  8] 8] 8 | adaptive by iteself, but it is possible to 
| 9  9  9  9] 9 | make it adaptive.
|---------------|
| #Comp: 4      |
| #Swap: 0      | => O(n) - if already sorted, minimum time 
| #max swap: 4  |
#+END_SRC
*** Կոդ
#+BEGIN_SRC C
void BubbleSort(int A[], int n)
{
 // no swapping means the list already sorted
 // we use flag to determine if there is a swap. 
 int flag = 0;
 for(i = 0; i < n-1; i++) // passes
 {
   for(j = 0, flag = 0; i < n-1-i; j++) // every pass reduced comparision count 
   {
     if(A[j] > A[j+1])
     {
       swap(A[j], A[j+1]);
       flag = 1;  
     }
   }
   if(flag == 0) break;  
 }
}
#+END_SRC

** Տեղադրմանբ (Insertion sort) 
** Ընտրությամբ (Selection sort)
** Արագ (Quick sort)
