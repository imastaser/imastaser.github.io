---
title: Տեսակավորման ալգորիթմներ
tags: sorting, algorithms
date: 2020-12-02
description: DESCRIPTION
comments: true
toc: true
---

* Տեսակավորման ալգորիթմներ
*Կայունությունը (stability)* - եթե տեսակավորման ալգորիթմը պահպանում է հավասար էլեմնենտների խոխադարձ տեղակայումը, 
ապա այսպիտի սորտավորման ալգորիթմը կանվանենք կայուն:

*Ադապտիվություն (adaptive)* - կասենք տեսակավորման ալգորիթմը ադապտիվ է եթե նախօրոք 
սորտավորված տվյալների վրա ծախսում է մինիմում ժամանակ՝ ցուցադրում է իր լավագույն ժամանակը(Best case):

*Տվյալների կառուցվածքը* եթե հատուկ չի նշվում, ալգորթմը նկարագրելիս, նշանակում է խոսքը միաչափ զանգվածի մասին է


#+BEGIN_SRC C
// http://www.cheat-sheets.org/saved-copy/bigoposter.pdf

#+END_SRC

|------------------------------+--------+----------+-------------+-------------+--------+------------------+-----------|
| Տեսակավորման ալգորիթմներ     | Stable | Adaptive | Best        | Average     | Worst  | Type             | Space     |
|------------------------------+--------+----------+-------------+-------------+--------+------------------+-----------|
| Պղպջակային (Bubble sort)     | Yes    | Yes      | Ω(n)        | θ(n^2)      | O(n^2) | Comparision sort | O(1)      |
| Տեղադրմամբ (Insertion sort)  | Yes    | Yes      | Ω(n)        | θ(n^2)      | O(n^2) |                  | O(1)      |
| Ընտրւոթյամբ (Selection sort) |        | No       | Ω(n^2)      | θ(n^2)      | O(n^2) |                  | O(1)      |
| Quicksort                    | No     | No       | Ω(n*log(n)) | θ(n*log(n)) | O(n^2) |                  | O(log(n)) |
| Mergesort                    |        |          |             |             |        |                  | O(n)      |
|                              |        |          |             |             |        |                  |           |
| Count Sort                   |        |          |             |             |        | Index sort       |           |
| Bucket/Bin Sort              |        |          |             |             |        |                  | O(n)      |
| Redix Sort                   |        |          |             |             |        |                  | O(n+k)    |
| Shell Sort                   |        |          |             |             |        |                  | O(1)      |
|------------------------------+--------+----------+-------------+-------------+--------+------------------+-----------|


** Պղպջակային (Bubble sort ) 
Համեմատության եղանակով տեսակավորման ալգորիթմ է, որը կարգավորում է զանգվածը ցույգ առ ցւոյգ 
համեմատելով հարևան էլեմնենտերը և տեղափոխելով իրար միջև եթե սխալ են դասավորված իրար նկատմամբ: 
Այսպիսի մի համեմատությունների և տեղափոխությունների անցումի մեկ ցիկլը էլեմենտների վրայով 
կանվանենք *Փաս(Pass)*: Առաջին Փասի արդյունքում մեկ էլեմենտ կգտնի իր տեղը, մեծագույն էլեմենտը զանգվածում կկարգավորվի: 
`n` էլեմնետ ունեցող զանգվածում հարկավոր կլինի n-1 Փաս ամբողձ զանգված հերթականուլյամբ դասավորելու համար: 
Իսկ n էլեմենտի համար պետք է կատարել n-1 համեմատություն և մաքսիմում n-1 տեղափոխություն՝
հերթական «ծանր» էլեմենտը իր տեղ դնելու համար: 
#+BEGIN_SRC C
  int A[] = {9,6,8,4,3}

| I Pass         | II Pass      | III Pass     | IV Pass      |
|----------------+--------------+--------------+--------------|
| 9] 6  6  6  6  | 6] 6  6  6   | 6] 4  4      | 4] 3.        |
| 6] 9] 8  8  8  | 8] 8] 4  4   | 4] 6] 3      | 3] 4.        |
| 8  8] 9] 4  4  | 4  4] 8] 3   | 3  3] 6.     | 6. 6.        |
| 4  4  4] 9] 3  | 3  3  3] 8.  | 8. 8. 8.     | 8. 8.        |
| 3  3  3  3] 9. | 9. 9. 9. 9.  | 9. 9. 9.     | 9. 9.        |
|----------------+--------------+--------------+--------------|
| sorted el.  9  | sorted el. 8 | sorted el. 6 | sorted el. 4 |
| #Comp: 4       | #Comp: 3     | #Comp: 2     | #Comp: 1     |
| #Swap: 4       | #Swap: 2     | #Swap: 2     | #Swap: 1     |
| #max swap: 4   | #max swap: 3 | #max swap: 2 | #max swap: 1 | 
#+END_SRC
  

*** Վերլուծություն
#+BEGIN_SRC C
Դիցուք ունենք n տարրանի զանգված, ապա.
- Փասերի քանակը՝ (n-1)
- Համեմատությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
- Մաքսիմալ հնարավոր տեղափոխությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
#+END_SRC

*Կայու՞ն է* - այո
#+BEGIN_SRC C
|--------------------|
| 9 ] 9   9   9   9  | No change of order, => Bubbke sort is stable
| 9*] 9*] 3   3   3  |
| 3   3 ] 9*] 5   5  |
| 5   5   5 ] 9*] 4  |
| 4   4   4   4 ] 9* |
|--------------------|
#+END_SRC

*Ադապտի՞վ է* - այո

Պղպջակային ալգորիթմը իր բնույթով *ադապտիվ* չէ, բայց այն հնարավոր է դարձնել ադապտիվ, 
կոդի մեջ այդ նպատակի համար օգտագործում ենք flag փոփոխականը որողելու համար հերթական փասի 
ընթացքում գոնե մեկ տեղափոխություն(swap) եղել է, եթե չի եղել նշանակում է տվյալնեն արդեն
կարգավրոված են:

#+BEGIN_SRC C
| sorted list   |
|---------------|
| 3] 3  3  3  3 | No swaping, mean list already sorted, we use 
| 4] 4] 4  4  4 | flag to determine if ther is swap and made 
| 6  6] 6] 6  6 | buuble sort algorithm adaptive, it is not 
| 8  8  8] 8] 8 | adaptive by iteself, but it is possible to 
| 9  9  9  9] 9 | make it adaptive.
|---------------|
| #Comp: 4      |
| #Swap: 0      | => O(n) - if already sorted, minimum time 
| #max swap: 4  |
#+END_SRC

*** Դիտողություններ
-  Այս տեսակավորման միջանկյալ արդյունքները՝ k Փաս-ից հետո,  k < n-1, նույնպես կարող են օգտակար լինեն, 
   քանի որ ամեն Փասի ընթացքում «ամենածանր» տարրը իջնում է ներքև, հետևաբար 1-ին փասից հետո կունենաք
   մեծագույն տարրը, 2-րդից հետո երկու մեծագույն տարրերը և այդպես շարունակ:
   


*** Կոդը
#+BEGIN_SRC C
void BubbleSort(int A[], int n)
{
 // no swapping means the list already sorted
 // we use flag to determine if there is a swap. 
 int flag = 0;
 for(i = 0; i < n-1; i++) // passes
 {
   for(j = 0, flag = 0; i < n-1-i; j++) // every pass reduced comparision count 
   {
     if(A[j] > A[j+1])
     {
       swap(A[j], A[j+1]);
       flag = 1;  
     }
   }
   if(flag == 0) break;  
 }
}
#+END_SRC




** Տեղադրմանբ (Insertion sort) 
- Նախ հասկանանք ի՞նչ նկատո ունենք *տեղադրում* ասելով
#+BEGIN_SRC C
int A[] = {2,6,10, * ,15,20,25,30}
int new_element = 12
#+END_SRC
Դիգուք ունենք հերաթականությմաբ դասավորված զանգվածը որի մեջ ուոզում ենք դեծադրել նոր էլեմենտ 12 
իր իր տեղում որ չխաղտի դասավորվածությունը: Դրա համար պետք է անել երկու բան
1. գտնել 12 տեղը զանգվածում
2. և տեղափոխել այդ տեղից սկսած բոլոր տարրերը դեպի աջ, ազատելով 12 տեղը

Ավելի օպտիմալ կլինի եթե շրջանցենք առաջին քայլը՝ սկսենլով ուղղակի տեծափոխել զանգվածի վերջին 
էլեմենտը դեպի աջ և միաժամանակ փնտրելով նոր տեծադրվոծ էլեմենտի տեղը.

#+BEGIN_SRC C
int A[] = {2,6,10,15,20,25,30,*}
int new_element = 12

- 30 > 12 Yes, shift it - {2,6,10,15,20,25,*,30}
- 25 > 12 Yes, shift it - {2,6,10,15,20,*,25,30}
- 20 > 12 Yes, shift it - {2,6,10,15,*,20,25,30}
- 15 > 12 Yes, shift it - {2,6,10,*,15,20,25,30}
- 10 > 12 No,  insert   - {2,6,10,12,15,20,25,30}

// in case Linked list
Node<int> first = 2 --> 6 --> 10 --> 15 --> 20 --> 25 --> 30
p = first;
q = NULL; //tail pointer
x = 18;
// we do not need shifting in linked list, we just need to trabel and fine out the right position of new element

procedure:
- p.data < x, yes q = p; p = p.next;
- p.data < x, yes q = p; p = p.next;
.......
- p.data < x, no, t = new Node(x);, t.next = p; q.next = t;

Min number of Comparisions: 0   ~ O(1)
Max number of Comparisions: n-1 ~ O(n)

Number of Swaps:        0 , not required    

#+END_SRC



*Ալգորիթմը*

Դիցուք ունենք 5 տարրանի A զանգվածը, պետք է տեսակավորենք: 
Ենթադրում ենք որ առաջին տարր իր տեղում է, իսկ մնացած 4 տարրերը պետք է դասավորենք *տեղադրով* մեկ առ մեկ՝
վերը նկարագրված եղանակով. առաջին մի տարրանի սորտավորված զանգվածի մեջ.

#+BEGIN_SRC C
int A[] = {9,6,8,4,3}

| I Pass            | II Pass           | III Pass           | IV Pass           |
|-------------------+-------------------+--------------------+-------------------|
| 9 * 8 4 3         | 6 9 * 4 3         | 6 8 9 * 3          | 4 6 8 9 *         |
| 6                 | . 8               | . . 4              | . . . 3           |
| 9 > 6, yes, shift | 9 > 8, yes, shift | 9 > 4, yes, shift  | 9 > 4, yes, shift |
| 6 9 8 4 3         | 6 * 9 4 3         | 6 8 * 9 3          | 4 5 8 * 9         |
|                   | 8                 | . 4                | . . 3             |
|                   | 6 > 8, no, insert | 8 > 4, yes, shift  | 8 > 3, yes, shift |
|                   | 6 8 9 4 3         | 6 * 8 9 3          | 4 5 * 8 9         |
|                   |                   | 6 > 4, yes, shift  | . 3               |
|                   |                   | * 6 8 9 3          | 5 > 3, yes, shift |
|                   |                   | 4                  | 4 * 5 8 9         |
|                   |                   | no element, insert | 3                 |
|                   |                   | 4 6 8 9 3          | 4 > 3, yes, shift |
|                   |                   |                    | * 4 5 8 9         |
|                   |                   |                    | 3, insert         |
|                   |                   |                    | 3 4 5 8 9         |
|-------------------+-------------------+--------------------+-------------------|
| sorted el.  6     | sorted el. 8      | sorted el. 4       | sorted el. 3      |
| #Comp: 1          | #Comp: 2          | #Comp: 3           | #Comp: 4          |
| #Swap: 1          | #Swap: 1          | #Swap: 3           | #Swap: 4          |
| #max swap: 1      | #max swap: 2      | #max swap: 3       | #max swap: 4      |

#+END_SRC

*** Վերլուծություն
#+BEGIN_SRC C
Դիցուք ունենք n տարրանի զանգված, ապա.
- Փասերի քանակը՝ (n-1)
- Համեմատությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
- Մաքսիմալ հնարավոր տեղափոխությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)

|      | min - Best case    | max: Worst case     |
|------+--------------------+---------------------|
| Time | O(n)               | O(n^2)              |
| Swap | O(1)               | O(n^2)              |
|------+--------------------+---------------------|
|      | in ascending order | in descending order |

#+END_SRC

*Կայու՞ն է* - այո

Դիտարկենք զանգված որը տեսակավորել ենք տեադրմամբ, և ունենք կնկնվող էլեմենտ 6' որի հերթն է տեծադրելու 
զանգվածի կարգավորված մասում, քանի որ մենք ստուգում ենք աջից խիստ անհավասարություն, այսինք հավասար էլեմենտնրը չի 
տեղափոխում, արդյունքում էլ այս երկրորդ 6' կհայտնվի առաջին վեցից աջ, ինչպես չկարգավորված զանցվածում էր, 
հետԵբար տեղադրմամբ տեսակավորումը կայուն է:

#+BEGIN_SRC C
    |----------------|
    | 4 6 9 11 12 *  |
    |          6'    |
    |    . . .       |
    | 4 6 6' 5 11 12 |
    |----------------|
#+END_SRC


*Ադապտի՞վ է* - այո

Տեղադրությամբ տեսակավորումը ադապտիվ է իր բնույթով՝ կարիք չկա լրացուցիչ ինչ որ
flag կամ այլ մի բան օգտագործենլու որպեսզի այն դառնա ադապտիվ:

#+BEGIN_SRC C
int A[] = {3,6,9,10,12}

| I Pass            | II Pass           | III Pass           | IV Pass             |
|-------------------+-------------------+--------------------+---------------------|
| 3 * 9 10 12       | 3 6 * 10 12       | 3 6 9 * 12         | 3 6 9 10 *          |
| 6                 | . 9               | . . 10             | . . . 12            |
| 3 > 6, no, insert | 6 > 9, no, insert | 9 > 10, no, insert | 10 > 12, no, insert |
|-------------------+-------------------+--------------------+---------------------|
| #Comp: 1          | #Comp: 1          | #Comp: 1           | #Compo: 1           |
| #Swap: 0          | #Swap: 0          | #Swap: 0           | #Swap: 0            | 

Number of Comparisions: n - 1 ~  O(n)
Number of Swaps:        0 ~ O(1) 

#+END_SRC

*** Դիտողություններ
- Տեղադրմամբ տեսակավորումը չունի օգտակար միջանկյալ արդյունք՝ k Փաս-ից հետո,  k < n-1
- Այս տեսակավորումը իրականացնելիս նպատակահարմար է օգտագործել կապակցված ցուցակ, որովհետև 
  էլեմենտների տեծափոխությյուն կատարելու անհրաժեշտությունը չկա: Հակառակն էլ է ճիշտ, կապակզված 
  ցուցակ տեսակավրոելու համար ավելի հարմար է տեղադրմամբ տեսակավորման ալգորիթմը:

*** Կոդը
#+BEGIN_SRC C
  void InsertionSort(int A[], int n)
  {
    int i, j, x;
    for(i = 1; i < n; i++) //passes
    {
      j = i - 1;
      x = A[j]; // the element we want to sort, to insert in the sorted part of array
      while(j > -1 && A[j] > x)
      {
        A[j + 1] = A[j];
        j--;  
      }
      A[j + 1] = x;
    }
  }
#+END_SRC


** Ընտրությամբ (Selection sort)

Այս ալգորիթմը նույնպես տեսակավարում է Փասերով: Ամեն Փասում մի էլեմենտ գտնում է իր տեղը՝ տեսակավրովում է:
Առաջին Փասում մենք ընտրում ենք առաջին տեղը և փնտրում ենք էլեմենտը այդ տեղի համար:

#+BEGIN_SRC
int A[] ={9,7,4,3,6,5}
int i - pointing the position, that element will come in this place: minimum element
// will use two more pointers to find minimum
int j = k = i;

Steps for each pass
int j = k = i;
1. move j to the next element
2. from j = k to n do check if A[j] < A[k] then k = j; j++; else j++;
3. swap(A[i], A[k])

After I Pass first element is sorted, now we should find an element for a second postion i = 1;

//We select a position and finding an element for that position
| I Pass          | II Pass         | III Pass         | IV Pass         | V Pass          |
|-----------------+-----------------+------------------+-----------------+-----------------|
| 9 <- i,j,k      | 3             3 | 3                | 3            3  | 3            3  |
| 7               | 7 <- i,j,k    4 | 4                | 4            4  | 4            4  |
| 4               | 4             7 | 7<-i,j,k         | 5            5  | 5            5  |
| 3               | 9             9 | 9                | 9 <- i,j,k   6  | 6            6  |
| 6               | 6             6 | 6                | 6            9  | 9 <-i,j,k    7  |
| 5               | 5             5 | 5                | 7            7  | 7            9  |
|                 |                 |                  |                 |                 |
| at the end:     | at the end:     | at the end:      | at the end:     | at the end:     |
| i = 0           | i = 1           | i = 2            | i = 3           | i=4             |
| k = 3           | k = 2           | k = 5            | k = 4           | k=5             |
| j = 6           | j = 6           | j = 6            | j = 6           | j=6             |
| swap(A[i],A[k]) | swap(A[i],A[k]) | swap(A[i],A[k])  | swap(A[i],A[k]) | swap(A[i],A[k]) |
| one el. sorted  | two el. sorted  | three el. sorted | four el. sorted | all el. sorted  |
| smallest el.    | two smallest    | three smallest   | IV ....         | V .....         |
|-----------------+-----------------+------------------+-----------------+-----------------|
| #Comp: 5        | #Comp: 4        | #Comp: 3         | #Comp: 2        | #Comp: 1        |
| #Swap: 1        | #Swap: 1        | #Swap: 1         | #Swap: 1        | #Swap: 1        |

Number of Passes: n-1
Number of comparisions: 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
Number of swap: n-1 ~ O(n)
#+END_SRC


*** Վերլուծություն

#+BEGIN_SRC C
Դիցուք ունենք n տարրանի զանգված, ապա.
- Փասերի քանակը՝ (n-1)
- Համեմատությունների քանակը՝ 1+2+...+n-1 = n*(n-1)/2 ~ O(n^2)
- տեղափոխությունների քանակը՝ n-1 ~ O(n)
#+END_SRC

*Կայուն է* - ոչ

Հենց առաջին Փասի վերջւոմ կատարվող տեղափոխության ժամանակ  առաջին 8 կանցնի մյուս 8-ից՝ իրար նկատմամբ տեղերը կփոխվի. 
հետևաբար կայուն չէ:

#+BEGIN_SRC C
|  I Pass | after swap |
|---------+------------|
| i -> 8' |          2 |
|       3 |          3 |
|       5 |          5 |
|       8 |          8 |
|       4 |          4 |
|  k -> 2 |         8' |
|       7 |          7 |
#+END_SRC


*Ադապտիվ է* - ոչ

Ընտրությամբ տեսակավորման մեջ հնարավոր չէ այնպես անել որ ստուգի տվյալները արդեն իսկ դասավրոված են
հերթականությամբ. ինչպես դա արեցինք Պղպջակային տեսակավորման ընթացակարգում: Ընտրությամբ տեսակավորումը
միշտ աշխատում է O(n^2) ժամանակում:
    
*** Դիտողություններ
- Ընտրությամբ տեսակավորումը միակ տեսակավորման ալգորիթմն է, որը օգտագործում է մինիմում քանակի տեղափոխություն(swap):
- K Փաս հետո կունենանք k փոքագույն տարրերը, այսինք ընտրությամբ տեսակավորումը ունի օգտակար միջանկյալ արդյունք:
  Bubble sort K փաս հետո ունենւոմ ենք K մեծագույննեը այստեղ, K փոգրագույնները: 

*** Կոդը
#+BEGIN_SRC C
void SelectionSort(int A[], int n)
{
 for(i = 0; i < n-1; i++) // passes
 {
   for(j = k = i; j < n; j++) // every pass reduced comparision count
   {
     if(A[j] > A[k])
     {
       k = j;
     }
   }
   swap(A[i], A[k]);
 }
}
#+END_SRC



** Արագ (Quick sort)
*** Ներածություն
#+BEGIN_SRC C
(1) - [10' 3 20 70 40 90 80]
(2) - [80 70 40 30 20 10 90']
(3) - [40 30 20 50' 90 70 80]
#+END_SRC
(3)-ում 50 իր տեղում է, քանի որ բոլոր նախորդող տարրերը ավելի փոքր են իրենից և բոլոր հաջորդոծ տարրերը ավելի մեծ են: 
Արագ տեսակավորման ալգորիթմի հիմքում հենց այս գաղափարն է, որ տարրը իր տեղում է եթե բոլոր նախորդողները իրենից փոքր են, 
իսկ բոլոր հաջորդողները իրենից մեծ:

*** Բաժանման ընթացակարգ (Partitioning procedure)
- Ընտրում ենք առանցքային(pivot) տարրը
- որոշում ենք i, j տեղերը
- տեղափոխում ենք տարրերը
- Բերում ենք pivot իր տեղը, որը կկոչենք՝ բաժանման տեղ կամ գիծ


#+BEGIN_SRC C
Բաժանման ընթացակարգի իրականացման մանրամասերը և քայլերը.

- Առաջին էլեմնտը՝ 50 դիտարկում ենք որպես առանցքային(pivotal) տարր, և պետք է գտնենք այդ առանցքային տարրի
տեղը, դրա համար բոոր այն տարրերը որինք առանցքային տարրից՝ 50 փոքր են պետք լինեն իրենից ձախ և բոլոր այն տարրերը 
որոնք մեծ են ընտրված առանցքային տարրից՝ աջ կողմում:

- *i* - փնտրելու ենք այն տարրերը որոնք մեծ են առանցքային(pivot) տարրից 
- *j* - փնտրելու ենք այն տարրերը որոնք փոքր կամ հավասար են առանցքային(pivot) տարրից 
- *∞* - ենթադրենք որ ցուցակում չկա ավելի մեծ տարր քան մեր ընտրած առանցքային տարրն է. այդ 
 դեպքում որպեսզի կանգնեցնենք *i*-ն մեր տվյանլնեի զանգվածի վերջին տարրը դնենք մեծագույն արժեքը՝ 
 օրինակ INT32_MAX (Int.MaxValue)


int l = 0;
int h = 10;
int i = 0; int j = 9;
int pivot = A[l]; //50

A = [50 70 60 90 40 80 10 20 30 ∞]
      i                         j
---------------------------------

Steps:
| # |                                        |                                                        |
|---+----------------------------------------+--------------------------------------------------------|
| 1 | i++; j--;                              | [50 70 60 90 40 80 10 20 30 ∞]                         |
|   |                                        |     i                    j                             |
|   | if(A[i] > pivot) && if(A[j] <= pivot)) | Yes, Yes                                               |
|   | then swap(A[i], A[j])                  | [50 30 60 90 40 80 10 20 70 ∞]                         |
|   |                                        |                                                        |
|---+----------------------------------------+--------------------------------------------------------|
| 2 | i++; j--;                              | [50 30 60 90 40 80 10 20 70 ∞]                         |
|   |                                        |        i              j                                |
|   | if(A[i] > pivot) && if(A[j] <= pivot)) | Yes, Yes                                               |
|   | then swap(A[i], A[j])                  | [50 30 20 90 40 80 10 60 70 ∞]                         |
|---+----------------------------------------+--------------------------------------------------------|
| 3 | i++; j--;                              | [50 30 20 90 40 80 10 60 70 ∞]                         |
|   |                                        |           i        j                                   |
|   | if(A[i] > pivot) && if(A[j] <= pivot)) | Yes, Yes                                               |
|   | then swap(A[i], A[j])                  | [50 30 20 10 40 80 90 60 70 ∞]                         |
|---+----------------------------------------+--------------------------------------------------------|
| 4 | i++; j--;                              | [50 30 20 10 40 80 90 60 70 ∞]                         |
|   |                                        |              i   j                                     |
|   | if(A[i] > pivot) && if(A[j] <= pivot)) | No, No                                                 |
|   | continue i++; if greater stop          | [50 30 20 10 40 80 10 20 70 ∞]                         |
|   | continue j--; if smaller stop          |                                                        |
|---+----------------------------------------+--------------------------------------------------------|
|   |                                        |                                                        |
| 5 | when (i > j)                           | yes, swap(pivot, A[j])                                 |
|   |                                        |                                                        |
|   |                                        | [(30 20 10 40) 50 (80 10 20 70) ∞]                     |
|   |                                        |                ..                                      |
|   |                                        | ths pivotal element in its place, one lement is sorted |
|   |                                        | this .. position called "Partitioning postition"       |
|   |                                        | for infinity element for left hand side list is a      |
|   |                                        | sorted element 50                                      |
|---+----------------------------------------+--------------------------------------------------------|
#+END_SRC

*Բաժանման պրոցեդուրայից* հետո ունենում ենք երկու բաժանված՝ աջ և ձախ զանգվածներ որոնք նույնպես պետք է սորտավորենք:
Ի՞նչպես անել դա: Պատասխանն էլ հենց այն է ինչ կանվանենք *արագ տեսակավորման ալգորիթմ* և որը 
կկիրառենք *ռեկուրսիվ* եղանակով այդ բաժանված աջ և ձախ կեսերի վրա: Ձախ կեսի համար որես *∞* տարր կհանդիսանա հենց նոր սորտավորված
առանցքային էլեմենտը


*** Վերլուծություն
Նախքան վերլուծությունը տեսնենք թէ Արագ տեսակավորման ալգորիթմը ինչպես է աշխատում 2 և 3 տարրանի զանգվաղների վրա, նախօրոք 
սորտավորվաԾների վրա


Օրինակ. 3 տարրանի զանգվածի
#+BEGIN_SRC C
[20 10 30 ∞] => [20 10 30 ∞], i > j => swap (pivot, A[j]) => [10 20 30 ∞]
 i        j      *  j   i      
առանցքային էլեմենտը՝ 20 տեղափոխությունից հետո հայտնվելով իր տեղում զանգվածը բաժանում մի մի տարրանոց մասերի, 
իսկ մեկ տարրանոց զանգվաը համարում ենք սորտավորված, հետևաբար ամբողջ զանգվածը տեսակավորված է:
#+END_SRC

Օրինակ. 2 տարրանի զանգվածի
#+BEGIN_SRC C
[20 10 ∞] => [10 20 ∞] i > j => swap(pivot, A[j]) => (10)(20) ∞
առանցքային տարր նույնն է ինչ որ A[j], տեղափոփում ենք ինքն իր հետ
#+END_SRC

Զանգվածը դասավորված է ըստ աճման կարգի
#+BEGIN_SRC C
[10 20 30 40 50 ∞]
 i              j   
|    |                          |                                 |            |
|----+--------------------------+---------------------------------+------------|
| 1. | [10' 20 30 40 50 ∞]      | n - elments                     | #Comp: n   |
|    | i               j        |                                 |            |
|    | [10' 20 30 40 50 ∞]      |                                 |            |
|    | j    i                   | i > j, => swap (el', A[j])      |            |
|    | [() 10' (20 30 40 50) ∞] | no element in left side         |            |
|----+--------------------------+---------------------------------+------------|
|    | [20' 30 40 50 ∞]         | n-1 - elements                  | #Comp: n-1 |
| 2. | i            j           |                                 |            |
|    | [20' 30 40 50 ∞]         |                                 |            |
|    | j    i                   | i>j, => swap(el', A[j]), itself |            |
|----+--------------------------+---------------------------------+------------|
| 3. | [30' 40 50 ∞]            | n-2 - elements                  | #Comp: n-2 |
|    | i        j               |                                 |            |
|    | [30' 40 50 ∞]            |                                 |            |
|    | j    i                   | i>j, => swap(el', A[j]), iself  |            |
|----+--------------------------+---------------------------------+------------|
| 4. | [40' 50 ∞]               | 2 - elements                    | #Comp: 2   |
|    | i     j                  |                                 |            |
|    | [40' 50 ∞]               |                                 |            |
|    | j    i                   | i>j, => swap(el', A[j]), isself |            |
|----+--------------------------+---------------------------------+------------|
| 5. | [50 ∞]}                  | 1 - elemetn                     |  #Comp: 1  |
|    |                          |                                 |            |
|----+--------------------------+---------------------------------+------------|


recursive call tree
[n]
  \
   [n-1]
     \
     [n-2]
       \
       ...
         \ 
         [2]
           \
           [1]  


Ըստ աճման կարգի դասավրոված զանցվածի վրա համեմատությունների քանակը՝ 
1+2+...+n-1 = n*(n-1)/2 ~ O(n^2) - ամենավատ տարվերակն է քանի որ բաժանման տեղը ձախ եզրային տարրն է:

#+END_SRC

Զանգվածը դասավրոված է ըստ նվազման կարգի
#+BEGIN_SRC C
[50 40 30 20 10 ∞]
 i              j   

|----+---------------------+---------------------------------+------------|
|    | [50' 40 30 20 10 ∞] | n - elements                    | #Comp: n   |
| 1. | i            j      |                                 |            |
|    | [50' 40 30 20 10 ∞] |                                 |            |
|    | .             j  i  | i>j, => swap(el', A[j])         |            |
|    | [10 40 30 20 50 ∞]  | no element in right side        |            |
|----+---------------------+---------------------------------+------------|
|    | [10' 40 30 20 ∞]    | 50 act like infinity            | #Comp: n-1 |
| 2. | i            j      |                                 |            |
|    | [10' 40 30 20 ∞]    |                                 |            |
|    | j   i               | i>j, => swap(el', A[j]), itself |            |
|    | [10 40 30 20 ∞]     | no element in left side         |            |
|----+---------------------+---------------------------------+------------|
| 3. | [40 30 20 ∞]        |                                 | #Comp: n-2 |
|    | ......              |                                 |            |
|    |                     | no element in right side        |            |

   [n]
   /
 [n-1]
     \
     [n-2]
    /
 ...
 
Ըստ նվազման կարգի դասավրոված զանցվածի վրա համեմատությունների քանակը՝ 
1+2+...+n-1 = n*(n-1)/2 ~ O(n^2) - ամենավատ տարբերակն է (Worst case), քանի որ բաժանման տեղը ձախ կամ աջ եզրային տարրն է, 
և  ստացված զանգվաղներից մեկը մի շտա դատարկ է իսկ մյուսը պարունակում է մնացած տարրերը:

#+END_SRC

*Լավագույն տարբերակը (Best case)*

Դիցուք ամեն անգամ *բաժանման տեղը* մեջտեղում է, այդ դեպքում րեկւորսիվ կանչերի ծառը կունենա այսպիսի տեսք՝

#+BEGIN_SRC C

n=15
n - recursive calls

               [1-15] ~ #Comp: n 
              /  8   \
             /         \
         [1-7]          [9 - 15] ~ #Comp: n
         / 4 \           / 12   \
    [1-3]   [4-7]       [9-12]    [13-15] ~ #Comp: n
    / 2 \   / 6 \       / 10 \      / 14  \ 
[1,1] [3,3][5,5][7,7] [9,9][11,11] [13,13][15,15] ~ #Comp: n

Ծառի բարձրությունը log(n), ամեն մակարդակում իրականացվում է n համեմատությում, բոլոր համեմատությունների քանակը՝ n*log(n):

Average Case: T = O(n*log(n))
Best Case:   T = O(n*log(n)),  if partitioning dome in a middle. 
Worst Case:  T = O(n^2),  if partitioning at any end of the list - left or right: list already sorted.
#+END_SRC

*** Դիտողություններ
- Արագ տեսակավորման ալգորիթմը ռեկուրսիվ ձևով օգտագործում է Բաժանման ընթացակարգը:
- Արագ տեսակավորման ալգորիթմը կարող է աշխատել առնվազն 2 տարր պարունակող զանգվածի վրա, մեկ տարրը արդեն կարգավրոված է
  և կարիք չունի այլևս տեսակավորման:
- «Արագ» բառը չի նշանակւոմ ամենարագ տեսակավորման ալգորիթն է: «Արագ» ավելի շատ նկատոի ունեն, որ ընտրված էլեմենտը շատ արագ գտնում է
  իր տեղը
- Արագ տեսակավորման այլ անունները՝
  - Selection Echange Sort
  - Partition Exchange Sort
  - Quick Sort

- Զուգահեռներ՝ ընտրությամբ և արագ տեսակավորման ալգորիթմների աշխատանքի սկզբունքներում: Ընտրությամբ տեսակավորման դեպքում. 
 ընտրում ենք տեղ և փնտրում ենք տարրը որը պետք է լինի այդ տեղում, իսկ արագ տեսակավորման 
 ժամանակ՝ ընտրոմ ենք էլեմենտը և փնտրոէմ գտնում ենք այն տեղը որտեծ պետք է գտնվի այդ տարրը:
  - selecting a position finding an element vs selecting an element finding a position
  - index vs element

#+BEGIN_SRC C
// middle element as pivotal
we can select middle element as pivot, exchanging with first element, then:
Best Case: O(nlog(n)) - sorted list
Worst case: partitioning at any ent - O(n^2) -  no definition of how looks the list of worst case


// Randomly selected pivotal element - Randomised quick sort
Best case: partitioning in the middle
Wors case: partitioning at any end of the list



#+END_SRC

*** Կոդը
#+BEGIN_SRC C
int partition(int A[],int l,int h)
{
  int pivot=A[l];
  int i=l,j=h;
  do
  {
    do{i++;}while(A[i] <= pivot);
    do{j--;}while(A[j] > pivot);
    if(i < j) swap(&A[i], &A[j]);

  }while(i < j);

  swap(&A[l], &A[j]);

  return j;
}

void QuickSort(int A[],int l,int h)
{
  int j;
  if(l < h)
  {
    j = partition(A,l,h);
    QuickSort(A,l,j);
    QuickSort(A,j+1,h);
  }
}

void swap(int *x,int *y)
{
  int temp=*x;
  *x = *y;
  *y = temp;
}

int main()
{
  int A[] = {11, 13, 7, 12, 16, 9, 24, 5, 10, 3, INT32_MAX};
  int n = 11, i;

  QuickSort(A, 0, n-1);

  for(i = 0; i < n; i++)
    printf("%d ", A[i]);

  printf("\n");
  return 0;
}

#+END_SRC
